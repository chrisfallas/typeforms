import{createContext as zz,useMemo as Az} from"react";import{v4 as Jz} from"uuid";import{useEffect as a,useMemo as p,useState as g} from"react";var e=({initialValues:J={},validateOnSubmit:$=!0,validateOnChange:T=!1,validateOnBlur:N=!1,schemaValidation:M,onChange:w,onSubmit:U})=>{const[Z,q]=g(J),[H,j]=g({}),[I,G]=g({isSubmitting:!1}),{isSubmitting:x}=I,S=async(z)=>G((A)=>({...A,isSubmitting:z})),D=(z)=>z?Z[z]:void 0,f=(z)=>z?H[z]:void 0,y=async(z,A,L)=>{const{include:K,exclude:Q}=L,Y={},_=await A(z);for(let X in _){let W=!0;if(K&&!K.includes(X))W=!1;if(Q&&Q.includes(X))W=!1;if(!W)continue;Y[X]=_[X]}return Y},F=async(z,A,L)=>{const{include:K,exclude:Q}=L,Y={};for(let _ in A){let X=!0;if(K&&!K.includes(_))X=!1;if(Q&&Q.includes(_))X=!1;if(!X)continue;const W=A[_],k=z[_],t=await W?.(k);Y[_]=t}return Y},P=async(z={})=>{const{data:A,updateFormState:L=!0}=z;if(!M||!A)return{};let K;if(typeof M==="function")K=await y(A,M,z);else K=await F(A,M,z);if(L)j((Y)=>({...Y,...K}));const Q={};for(let Y in K){const _=K[Y];if(_?.length)Q[Y]=_}return Q},B=(z)=>{let A=!1,L,K;if(typeof z==="boolean")A=z;else if(Array.isArray(z.include))A=!0,L=z.include;else if(Array.isArray(z.exclude))A=!0,K=z.exclude;return{isValidationRequired:A,include:L,exclude:K}},O=async(z)=>{const{isValidationRequired:A,include:L,exclude:K}=B(T),Q={};let Y=0;const _=[];for(let{name:X,value:W}of z){if(!X)continue;if(["",void 0,null].includes(W))Q[X]=void 0;else Q[X]=W;if(Q[X]!==D(X))Y++;let k=A;if(L&&!L.includes(X))k=!1;if(K&&K.includes(X))k=!1;if(!k)continue;_.push(X)}if(_.length)P({data:Q,include:_});if(Y>0)q((X)=>{const W={...X,...Q};return new Promise(()=>w?.(W)),W})},R=async(z,A)=>{if(!z||A===D(z))return;O([{name:z,value:A}])},d=async(z)=>{const A=z.target.name;if(!A)return;let L=z.target.value;if(L&&z.target.type==="number")L=Number(L);R(A,L)},r=async(z)=>{const A=z.target.name;if(!A)return;const{isValidationRequired:L,include:K,exclude:Q}=B(N);let Y=L;if(K&&!K.includes(A))Y=!1;if(Q&&Q.includes(A))Y=!1;if(!Y)return;P({data:Z,include:[A]})},o=async(z)=>{z.preventDefault(),S(!0);try{const{isValidationRequired:A,include:L,exclude:K}=B($);if(!A)await U?.({ok:!0,data:Z});else{const Q=await P({data:Z,include:L,exclude:K});if(!Object.keys(Q).length)await U?.({ok:!0,data:Z});else await U?.({ok:!1,errors:Q})}}finally{S(!1)}},l=async()=>{q(J),j({}),new Promise(()=>w?.(J))},i=p(()=>{const z=JSON.stringify(J),A=JSON.stringify(Z);return z!==A},[J,Z]),n=p(()=>{return!Object.keys(H).length},[H]);return a(()=>{console.log("errors",H)},[H]),{data:Z,isValid:n,isDirty:i,isSubmitting:x,errors:H,getValue:D,setValue:R,setValues:O,getErrors:f,onChange:d,onBlur:r,onSubmit:o,validate:P,reset:l}},V=e;import{jsxDEV as Lz} from"react/jsx-dev-runtime";var h=zz(null),Kz=({customFormId:J,initialValues:$,validateOnSubmit:T,validateOnChange:N,validateOnBlur:M,schemaValidation:w,onChange:U,onSubmit:Z,render:q,children:H})=>{const j=Az(()=>J||Jz(),[J]),G={...V({initialValues:$,validateOnSubmit:T,validateOnChange:N,validateOnBlur:M,schemaValidation:w,onChange:U,onSubmit:Z}),formId:j};return Lz(h.Provider,{value:G,children:q?q(G):H},void 0,!1,void 0,this)},v=Kz;import{jsxDEV as c} from"react/jsx-dev-runtime";var Qz=(J)=>{const{initialValues:$,validateOnSubmit:T,validateOnChange:N,validateOnBlur:M,schemaValidation:w,onChange:U,onSubmit:Z,children:q,id:H,render:j,...I}=J;return c(v,{customFormId:H,initialValues:$,validateOnSubmit:T,validateOnChange:N,validateOnBlur:M,schemaValidation:w,onChange:U,onSubmit:Z,render:(G)=>c("form",{id:G.formId,onSubmit:G.onSubmit,...I,children:j?j(G):q},void 0,!1,void 0,this)},void 0,!1,void 0,this)},u=Qz;import{useContext as Xz} from"react";var Yz=()=>{const J=Xz(h);if(!J)throw new Error("useFormContext must be used within a FormProvider");return J},b=Yz;var Zz=(J)=>{const $=b(),T=`${$.formId}-${J}`,N=$.getValue(J);return{id:T,value:N,setValue:async(w)=>{if(J)$.setValue(J,w)},onChange:$.onChange,onBlur:$.onBlur}},C=Zz;import{jsxDEV as E,Fragment as m} from"react/jsx-dev-runtime";var _z=(J)=>{const{id:$,name:T,value:N,onChange:M,onBlur:w,label:U,labelId:Z,labelClassName:q,labelRef:H,labelWrap:j,labelPlacement:I,render:G,...x}=J,{value:S,...D}=C(T),f=$||D.id,y=async(R)=>{D.onChange(R),new Promise(()=>M?.(R.target.value))},F=async(R)=>{D.onBlur(R),new Promise(()=>w?.(R))},P={...x,id:f,name:T,value:T?String(S??""):N,onChange:y,onBlur:F};if(G)return G(P);const B=E("input",{...P},void 0,!1,void 0,this);if(!U)return B;if(j==="wrap")return E("label",{id:Z,className:q,ref:H,children:[E("span",{children:U},void 0,!1,void 0,this),B]},void 0,!0,void 0,this);const O=E("label",{id:Z,className:q,ref:H,htmlFor:f,children:E("span",{children:U},void 0,!1,void 0,this)},void 0,!1,void 0,this);if(I==="bottom")return E(m,{children:[B,O]},void 0,!0,void 0,this);return E(m,{children:[O,B]},void 0,!0,void 0,this)},s=_z;var $z=()=>({Form:u,Input:s,applyTypes:(J)=>J}),bz=$z;export{C as useFormElement,b as useFormContext,bz as default};
