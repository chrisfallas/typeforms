import{createContext as a,useMemo as e} from"react";import{v4 as TT} from"uuid";import{useMemo as C,useState as y} from"react";var t=({initialValues:A={},validateOnSubmit:Y=!0,validateOnChange:R=!1,validateOnBlur:w=!1,schemaValidation:_,onChange:U,onSubmit:$})=>{const[X,W]=y(A),[L,H]=y({}),[D,N]=y({isSubmitting:!1}),{isSubmitting:f}=D,I=async(T)=>N((q)=>({...q,isSubmitting:T})),M=(T)=>T?X[T]:void 0,O=(T)=>T?L[T]:void 0,x=async(T,q)=>{const{include:z,exclude:K}=q,J={},Q=await T(X);for(let Z in Q){let B=!0;if(z&&!z.includes(Z))B=!1;if(K&&K.includes(Z))B=!1;if(!B)continue;J[Z]=Q[Z]}return J},S=async(T,q)=>{const{include:z,exclude:K}=q??{},J={};for(let Q in T){let Z=!0;if(z&&!z.includes(Q))Z=!1;if(K&&K.includes(Q))Z=!1;if(!Z)continue;const B=T[Q],l=M(Q),n=await B?.(l);J[Q]=n}return J},E=async(T)=>{const{updateFormState:q=!0,include:z,exclude:K}=T??{};if(!_)return{};let J;if(typeof _==="function")J=await x(_,{include:z,exclude:K});else J=await S(_,{include:z,exclude:K});if(q)H((Z)=>({...Z,...J}));const Q={};for(let Z in J){const B=J[Z];if(B?.length)Q[Z]=B}return Q},P=(T)=>{let q=!1,z,K;if(typeof T==="boolean")q=T;else if(Array.isArray(T.include))q=!0,z=T.include;else if(Array.isArray(T.exclude))q=!0,K=T.exclude;return{needsValidation:q,include:z,exclude:K}},k=async(T)=>{W((q)=>{const z={...q};let K=!1;for(let{name:J,value:Q}of T){if(!J||Q===M(J))continue;if(K=!0,["",void 0,null].includes(Q))z[J]=void 0;else z[J]=Q}if(K)U?.(z);return K?z:q})},G=async(T,q)=>{if(!T||q===M(T))return;k([{name:T,value:q}])},d=async(T)=>{const q=T.target.name;if(!q)return;let z=T.target.value;if(z&&T.target.type==="number")z=Number(z);G(q,z)},m=async(T)=>{const q=T.target.name;if(!q)return;const z=M(q);console.log("onBlur",q,z)},s=async(T)=>{T.preventDefault(),I(!0);try{const{needsValidation:q,include:z,exclude:K}=P(Y);if(!q)await $?.({ok:!0,data:X});else{const J=await E({updateFormState:!0,include:z,exclude:K});if(!Object.keys(J).length)await $?.({ok:!0,data:X});else await $?.({ok:!1,errors:J})}}finally{I(!1)}},r=async()=>{W(A),H({}),U?.(A)},i=C(()=>{const T=JSON.stringify(A),q=JSON.stringify(X);return T!==q},[A,X]),o=C(()=>{return!Object.keys(L).length},[L]);return{data:X,isValid:o,isDirty:i,isSubmitting:f,errors:L,getValue:M,setValue:G,setValues:k,getErrors:O,onChange:d,onBlur:m,onSubmit:s,validate:E,reset:r}},b=t;import{jsxDEV as zT} from"react/jsx-dev-runtime";var g=a(null),qT=({customFormId:A,initialValues:Y,validateOnSubmit:R,validateOnChange:w,validateOnBlur:_,schemaValidation:U,onChange:$,onSubmit:X,render:W,children:L})=>{const H=e(()=>A||TT(),[A]),N={...b({initialValues:Y,validateOnSubmit:R,validateOnChange:w,validateOnBlur:_,schemaValidation:U,onChange:$,onSubmit:X}),formId:H};return zT(g.Provider,{value:N,children:W?W(N):L},void 0,!1,void 0,this)},V=qT;import{jsxDEV as p} from"react/jsx-dev-runtime";var AT=(A)=>{const{initialValues:Y,validateOnSubmit:R,validateOnChange:w,validateOnBlur:_,schemaValidation:U,onChange:$,onSubmit:X,children:W,id:L,render:H,...D}=A;return p(V,{customFormId:L,initialValues:Y,validateOnSubmit:R,validateOnChange:w,validateOnBlur:_,schemaValidation:U,onChange:$,onSubmit:X,render:(N)=>p("form",{id:N.formId,onSubmit:N.onSubmit,...D,children:H?H(N):W},void 0,!1,void 0,this)},void 0,!1,void 0,this)},v=AT;import{useContext as JT} from"react";var KT=()=>{const A=JT(g);if(!A)throw new Error("useFormContext must be used within a FormProvider");return A},F=KT;var QT=(A)=>{const Y=F(),R=`${Y.formId}-${A}`,w=Y.getValue(A);return{id:R,value:w,setValue:async(U)=>{if(A)Y.setValue(A,U)},onChange:Y.onChange,onBlur:Y.onBlur}},h=QT;import{jsxDEV as j,Fragment as c} from"react/jsx-dev-runtime";var XT=(A)=>{const{id:Y,name:R,value:w,onChange:_,onBlur:U,label:$,labelId:X,labelClassName:W,labelRef:L,labelWrap:H,labelPlacement:D,render:N,...f}=A,{value:I,...M}=h(R),O=Y||M.id,x=(G)=>{M.onChange(G),_?.(G.target.value)},S=(G)=>{M.onBlur(G),U?.(G)},E={...f,id:O,name:R,value:R?String(I??""):w,onChange:x,onBlur:S};if(N)return N(E);const P=j("input",{...E},void 0,!1,void 0,this);if(!$)return P;if(H==="wrap")return j("label",{id:X,className:W,ref:L,children:[j("span",{children:$},void 0,!1,void 0,this),P]},void 0,!0,void 0,this);const k=j("label",{id:X,className:W,ref:L,htmlFor:O,children:j("span",{children:$},void 0,!1,void 0,this)},void 0,!1,void 0,this);if(D==="bottom")return j(c,{children:[P,k]},void 0,!0,void 0,this);return j(c,{children:[k,P]},void 0,!0,void 0,this)},u=XT;var YT=()=>({Form:v,Input:u,applyTypes:(A)=>A}),FT=YT;export{h as useFormElement,F as useFormContext,FT as default};
